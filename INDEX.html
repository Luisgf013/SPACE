<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Galactic Defender — Single File Game</title>
<style>
  /* Visual minimalista e legível */
  html,body{height:100%;margin:0;background:#071024;color:#e6f0ff;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #gameWrap{display:flex;align-items:center;justify-content:center;height:100%}
  canvas{background:linear-gradient(#020617,#04102a);border-radius:12px;box-shadow:0 8px 40px rgba(0,0,0,0.6)}
  .ui {
    position: absolute; left: 18px; top: 18px; color:#cfe8ff; font-weight:600;
    text-shadow:0 1px 0 rgba(0,0,0,0.6);
  }
  .overlay {
    position: absolute; inset:0; display:flex; align-items:center; justify-content:center;
    pointer-events:none;
  }
  .panel {
    background: rgba(2,6,23,0.85); border: 1px solid rgba(255,255,255,0.04);
    padding:18px; border-radius:10px; color:#e6f0ff; text-align:center; width:760px;
    pointer-events:auto;
  }
  button { background:#1463ff;color:white;padding:10px 14px;border:0;border-radius:8px;cursor:pointer;margin:6px }
  .muted { background:#334155 }
  .small { font-size:13px;color:#9fb6d9 }
  .controls { margin-top:10px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap }
  .credit { position: absolute; right: 18px; top: 18px; color:#9fb6d9; font-size:13px }
  @media (max-width:900px){
    .panel{width:92vw}
    canvas{width:92vw;height:calc(92vw*0.75)}
  }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="gameCanvas" width="960" height="720"></canvas>
  <div class="ui" id="hud" style="display:none">SCORE: 0 · LIVES: 3 · LEVEL: 1</div>
  <div class="credit">Galactic Defender — single-file demo</div>
  <div class="overlay" id="overlay">
    <div class="panel" id="mainMenu">
      <h1>Galactic Defender</h1>
      <p class="small">Defenda a galáxia! Use ← → ou A D para mover, espaço para atirar. Toque na tela para controles móveis.</p>
      <div class="controls">
        <button id="btnStart">Iniciar Jogo</button>
        <button id="btnContinue" class="muted">Continuar</button>
        <button id="btnHow" class="muted">Como jogar</button>
        <button id="btnToggleSound">Som: ON</button>
      </div>
      <p class="small" style="margin-top:8px">Highscore: <span id="highscore">0</span></p>
      <p class="small" style="margin-top:8px">Single-file HTML + JS — sem dependências externas.</p>
    </div>

    <div class="panel" id="pauseMenu" style="display:none">
      <h2>Pausado</h2>
      <div class="controls">
        <button id="btnResume">Retomar</button>
        <button id="btnRestart">Reiniciar</button>
        <button id="btnMain">Menu Principal</button>
      </div>
      <p class="small">Pressione P para pausar/retomar.</p>
    </div>

    <div class="panel" id="howPanel" style="display:none">
      <h2>Como jogar</h2>
      <ul style="text-align:left; margin-left:16px;">
        <li>Mova com ← → ou A D. Pressione Espaço para atirar.</li>
        <li>Pegue power-ups: Fire Rate, Spread, Shield e Vida.</li>
        <li>Chegue a níveis mais altos para enfrentar bosses.</li>
        <li>Pontuação aumenta ao destruir inimigos. Sobreviva o máximo possível.</li>
      </ul>
      <div class="controls">
        <button id="btnHowBack">Voltar</button>
      </div>
    </div>

    <div class="panel" id="gameOverPanel" style="display:none">
      <h2>Game Over</h2>
      <p class="small">Sua pontuação: <strong id="finalScore">0</strong></p>
      <div class="controls">
        <button id="btnRetry">Jogar Novamente</button>
        <button id="btnMenuFromOver">Menu</button>
      </div>
    </div>
  </div>
</div>

<script>
/*
  Galactic Defender
  Single-file browser game. Código grande e comentado para aproveitar o "limite".
  - Estrutura: inicialização, sistema de áudio, classes (Player, Enemy, Bullet, Powerup), loop principal, UI handlers.
  - Tudo sem imagens externas; gráficos desenhados via canvas.
*/

/* --------------------------
   Configurações e utilitários
   -------------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const hud = document.getElementById('hud');

let WIDTH = canvas.width, HEIGHT = canvas.height;
function resizeCanvasToWindow(){
  // Mantém proporção 4:3, mas responsivo via CSS; só atualiza lógica se necessário
  const rect = canvas.getBoundingClientRect();
  WIDTH = rect.width;
  HEIGHT = rect.height;
  // scale internal coordinate system so we draw cleanly regardless of CSS size
  canvas.width = Math.round(WIDTH);
  canvas.height = Math.round(HEIGHT);
}
resizeCanvasToWindow();
window.addEventListener('resize', resizeCanvasToWindow);

/* Timing */
let lastTime = performance.now();
function now(){ return performance.now(); }

/* Random util */
const rand = (a,b)=> Math.random()*(b-a)+a;
const randint = (a,b)=> Math.floor(rand(a,b+1));

/* Clamp */
const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));

/* --------------------------
   Audio: WebAudio simple synth
   -------------------------- */
let audioEnabled = true;
const AudioEngine = (function(){
  let ctx = null;
  function ensure(){
    if (ctx) return ctx;
    try {
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      return ctx;
    } catch(e){
      audioEnabled = false;
      return null;
    }
  }
  function playTone(freq, duration=0.12, type='sine', volume=0.08){
    if (!audioEnabled) return;
    const C = ensure();
    if (!C) return;
    const o = C.createOscillator();
    const g = C.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = volume;
    o.connect(g); g.connect(C.destination);
    const t0 = C.currentTime;
    o.start(t0);
    g.gain.setValueAtTime(volume, t0);
    g.gain.exponentialRampToValueAtTime(0.001, t0 + duration);
    o.stop(t0 + duration + 0.02);
  }
  function playExplosion(){
    if (!audioEnabled) return;
    const C = ensure();
    const o1 = C.createOscillator();
    const o2 = C.createOscillator();
    const g = C.createGain();
    o1.type='sawtooth'; o2.type='square';
    o1.frequency.value=rand(60,120);
    o2.frequency.value=rand(20,60);
    g.gain.value=0.12;
    o1.connect(g); o2.connect(g); g.connect(C.destination);
    const t0 = C.currentTime;
    o1.start(t0); o2.start(t0);
    g.gain.setValueAtTime(0.12, t0);
    g.gain.exponentialRampToValueAtTime(0.001, t0+0.4);
    o1.stop(t0+0.45); o2.stop(t0+0.45);
  }
  return {playTone, playExplosion, ensure};
})();

/* --------------------------
   Game state
   -------------------------- */
const GAME = {
  running: false,
  paused: false,
  score: 0,
  level: 1,
  lives: 3,
  wave: 0,
  highscore: parseInt(localStorage.getItem('gd_highscore')||'0',10),
  state: 'menu', // menu, playing, paused, gameover
  entities: [],
  bullets: [],
  enemies: [],
  powups: [],
  particles: [],
  player: null,
  lastEnemySpawn: 0,
  enemySpawnInterval: 1200, // ms
  lastWaveTime: 0
};

/* --------------------------
   Input handling
   -------------------------- */
const input = {
  left:false, right:false, fire:false, pointerDown:false, px:0, py:0
};

window.addEventListener('keydown', e=>{
  if (e.code === 'ArrowLeft' || e.key.toLowerCase() === 'a') input.left=true;
  if (e.code === 'ArrowRight' || e.key.toLowerCase() === 'd') input.right=true;
  if (e.code === 'Space') input.fire=true;
  if (e.code === 'KeyP') togglePause();
  // prevent scrolling page
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
});
window.addEventListener('keyup', e=>{
  if (e.code === 'ArrowLeft' || e.key.toLowerCase() === 'a') input.left=false;
  if (e.code === 'ArrowRight' || e.key.toLowerCase() === 'd') input.right=false;
  if (e.code === 'Space') input.fire=false;
});

/* Touch / pointer for mobile */
canvas.addEventListener('pointerdown', e=>{
  input.pointerDown=true;
  input.px = e.clientX - canvas.getBoundingClientRect().left;
  input.py = e.clientY - canvas.getBoundingClientRect().top;
});
canvas.addEventListener('pointermove', e=>{
  if (input.pointerDown){
    input.px = e.clientX - canvas.getBoundingClientRect().left;
    input.py = e.clientY - canvas.getBoundingClientRect().top;
  }
});
canvas.addEventListener('pointerup', e=>{
  input.pointerDown=false;
});

/* --------------------------
   Core classes
   -------------------------- */

class Particle {
  constructor(x,y,dx,dy,life,color,size=2){
    this.x=x;this.y=y;this.dx=dx;this.dy=dy;this.life=life;this.maxLife=life;
    this.color=color;this.size=size;
  }
  update(dt){
    this.x += this.dx*dt; this.y += this.dy*dt;
    this.life -= dt;
  }
  draw(ctx){
    const t = clamp(this.life/this.maxLife,0,1);
    ctx.save();
    ctx.globalAlpha = t;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

/* Bullets used by player and enemies */
class Bullet {
  constructor(x,y,dx,dy,owner='player',damage=1,color='#a6f0ff',radius=4){
    this.x=x;this.y=y;this.dx=dx;this.dy=dy;this.owner=owner;this.damage=damage;
    this.radius=radius; this.color=color; this.dead=false;
  }
  update(dt){
    this.x += this.dx*dt; this.y += this.dy*dt;
    // Out of bounds -> kill
    if (this.x < -20 || this.x > WIDTH+20 || this.y < -40 || this.y > HEIGHT+40) this.dead=true;
  }
  draw(ctx){
    ctx.save();
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

/* Power-ups */
class Powerup {
  constructor(x,y,type){
    this.x=x;this.y=y; this.type=type; this.size=14; this.dead=false; this.speed=40;
    this.created = now();
  }
  update(dt){
    this.y += this.speed*dt;
    if (this.y > HEIGHT + 20) this.dead = true;
  }
  apply(player){
    if (this.type === 'life') { player.lives = Math.min(player.lives+1, 5); GAME.lives = player.lives; }
    if (this.type === 'rate') { player.fireRate = Math.max(80, player.fireRate - 80); }
    if (this.type === 'spread') { player.spread = Math.min(3, player.spread + 1); }
    if (this.type === 'shield') { player.shield = 4.0; }
    // small sound
    AudioEngine.playTone(900,0.08,'square',0.06);
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x,this.y);
    // simple shapes per type
    ctx.fillStyle = {life:'#ff7b7b',rate:'#7bdcff',spread:'#ffd97b',shield:'#c6a6ff'}[this.type] || '#fff';
    ctx.beginPath(); ctx.arc(0,0,this.size,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#022'; ctx.font = '12px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const label = {life:'+1',rate:'FR',spread:'SP',shield:'SH'}[this.type]||'?';
    ctx.fillText(label,0,0);
    ctx.restore();
  }
}

/* Enemy blueprint */
class Enemy {
  constructor(x,y,pattern='straight',hp=1,speed=60,score=10,size=18,color='#ff8f8f'){
    this.x=x; this.y=y; this.pattern=pattern; this.hp=hp; this.maxHp=hp; this.speed=speed;
    this.dead=false; this.score=score; this.size=size; this.color=color;
    this.spawnTime = now();
    this.t = 0;
    this.shootCooldown = rand(900,2200);
    this.lastShot = 0;
    this.phase=0;
  }
  update(dt){
    this.t += dt*1000;
    // Pattern movement
    if (this.pattern === 'straight') {
      this.y += this.speed * dt;
    } else if (this.pattern === 'sine') {
      this.y += this.speed * dt;
      this.x += Math.sin((this.t)/300) * 40 * dt;
    } else if (this.pattern === 'zig') {
      this.x += Math.cos((this.t)/200)*this.speed*0.25*dt;
      this.y += this.speed*dt;
    } else if (this.pattern === 'boss') {
      // boss moves slowly, telegraphs shots
      this.x += Math.cos(this.t/500)*30*dt;
      // y stays roughly fixed
    }

    if (this.y > HEIGHT + 40) this.dead=true;

    // enemy shooting behavior (non-boss)
    if (this.pattern !== 'boss'){
      if (this.t - this.lastShot > this.shootCooldown){
        this.shootAtPlayer();
        this.lastShot = this.t;
        this.shootCooldown = rand(900,2200);
      }
    } else {
      // bosses have adapted shooting handled externally
    }
  }
  shootAtPlayer(){
    const p = GAME.player;
    if (!p) return;
    const dx = p.x - this.x;
    const dy = p.y - this.y;
    const mag = Math.hypot(dx,dy) || 1;
    const speed = 260;
    const vx = dx/mag*speed;
    const vy = dy/mag*speed;
    GAME.bullets.push(new Bullet(this.x,this.y,vx,vy,'enemy',1,'#ffccaa',5));
  }
  takeDamage(d){
    this.hp -= d;
    for (let i=0;i<6;i++){
      GAME.particles.push(new Particle(this.x, this.y, rand(-80,80), rand(-80,80), rand(300,700), '#ffb0b0', 2));
    }
    if (this.hp <= 0) this.die();
    else AudioEngine.playTone(880,0.05,'sine',0.04);
  }
  die(){
    this.dead = true;
    GAME.score += this.score;
    AudioEngine.playExplosion();
    // spawn particles
    for (let i=0;i<30;i++){
      GAME.particles.push(new Particle(this.x, this.y, rand(-180,180), rand(-180,180), rand(400,1000), '#ffa0a0', 3));
    }
    // chance of powerup
    if (Math.random() < 0.18){
      const types = ['life','rate','spread','shield'];
      GAME.powups.push(new Powerup(this.x, this.y, types[randint(0, types.length-1)]));
    }
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y);
    // body
    ctx.fillStyle = this.color;
    roundRect(ctx, -this.size/2, -this.size/2, this.size, this.size, 6);
    ctx.fill();
    // HP bar
    if (this.maxHp>1){
      const w = this.size;
      ctx.fillStyle = '#222';
      ctx.fillRect(-w/2, -this.size/2-8, w, 4);
      ctx.fillStyle = '#ff6b6b';
      ctx.fillRect(-w/2, -this.size/2-8, w * (this.hp/this.maxHp), 4);
    }
    ctx.restore();
  }
}

/* Player class */
class Player {
  constructor(){
    this.x = WIDTH/2;
    this.y = HEIGHT - 80;
    this.w = 44; this.h = 30;
    this.speed = 420; // px/sec
    this.fireRate = 220; // ms between shots
    this.lastShot = -9999;
    this.spread = 1; // number of bullets per shot
    this.lives = GAME.lives || 3;
    this.shield = 0; // seconds of shield
    this.invul = 0; // invulnerability after hit
  }
  update(dt){
    // movement from keyboard
    let mv = 0;
    if (input.left) mv -= 1;
    if (input.right) mv += 1;
    // pointer input moves player when touch dragging
    if (input.pointerDown){
      // smooth follow to pointer
      const targetX = input.px;
      const dx = targetX - this.x;
      mv = clamp(dx / 40, -1, 1);
    }
    this.x += mv * this.speed * dt;
    // clamp
    this.x = clamp(this.x, 20, WIDTH-20);
    // firing
    if (input.fire || input.pointerDown){
      const t = now();
      if (t - this.lastShot > this.fireRate){
        this.shoot();
        this.lastShot = t;
      }
    }
    // update shields/invul
    if (this.shield > 0) this.shield = Math.max(0, this.shield - dt);
    if (this.invul > 0) this.invul = Math.max(0, this.invul - dt);
  }
  shoot(){
    const baseSpeed = -560;
    const bullets = [];
    const spreadCount = this.spread;
    if (spreadCount === 1){
      bullets.push(new Bullet(this.x, this.y-24, 0, baseSpeed, 'player', 1, '#aef', 5));
    } else {
      const angleSpread = 18; // degrees
      const center = 0;
      const half = (spreadCount-1)/2;
      for (let i=0;i<spreadCount;i++){
        const angle = (i-half) * angleSpread * Math.PI/180;
        const vx = Math.sin(angle) * Math.abs(baseSpeed);
        const vy = Math.cos(angle) * baseSpeed;
        bullets.push(new Bullet(this.x, this.y-24, vx, vy, 'player', 1, '#aef', 5));
      }
    }
    bullets.forEach(b=> GAME.bullets.push(b));
    AudioEngine.playTone(1700 - this.spread*80, 0.06, 'square', 0.06);
  }
  takeHit(dmg=1){
    if (this.invul>0) return;
    if (this.shield > 0){
      // shield absorbs damage
      this.shield = Math.max(0, this.shield - 1);
      AudioEngine.playTone(1200,0.06,'sine',0.06);
      return;
    }
    this.lives -= dmg;
    GAME.lives = this.lives;
    this.invul = 1.4;
    AudioEngine.playTone(160,0.12,'sawtooth',0.12);
    // spawn hit particles
    for (let i=0;i<20;i++){
      GAME.particles.push(new Particle(this.x + rand(-20,20), this.y + rand(-10,10), rand(-200,200), rand(-200,200), rand(400,1000), '#ffd0d0', 2));
    }
    if (this.lives <= 0){
      // player dead
      GAMEOver();
    }
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x,this.y);
    // body
    ctx.beginPath();
    ctx.moveTo(-this.w/2, this.h/2);
    ctx.lineTo(0, -this.h/2);
    ctx.lineTo(this.w/2, this.h/2);
    ctx.closePath();
    ctx.fillStyle = '#aee6ff';
    ctx.fill();
    // cockpit
    ctx.beginPath();
    ctx.ellipse(0, -2, 10, 7, 0, 0, Math.PI*2);
    ctx.fillStyle = '#0d3a63';
    ctx.fill();
    // shield ring
    if (this.shield > 0){
      ctx.strokeStyle = 'rgba(182,154,255,0.8)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(0,0,34,0,Math.PI*2);
      ctx.stroke();
    }
    // invulnerability flash
    if (this.invul > 0){
      ctx.globalAlpha = 0.6 + 0.4*Math.sin(now()/60);
    }
    ctx.restore();
  }
}

/* --------------------------
   Helper drawing functions
   -------------------------- */
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* --------------------------
   Spawning enemies & waves
   -------------------------- */
function spawnEnemyWave(level){
  // Level shapes: increase count and HP
  const count = clamp(4 + Math.floor(level*1.6), 4, 28);
  for (let i=0;i<count;i++){
    const x = rand(40, WIDTH-40);
    const y = rand(-220, -40 - i*12);
    const pattern = (Math.random() < 0.4) ? 'sine' : 'straight';
    const hp = Math.min(1 + Math.floor(level/4), 6);
    const speed = clamp(60 + level*8 + Math.random()*40, 40, 200);
    const color = `hsl(${randint(0,50)},80%,60%)`;
    GAME.enemies.push(new Enemy(x,y,pattern,hp,speed, 10+level*2, 18, color));
  }
  GAME.lastWaveTime = now();
  GAME.wave++;
  GAME.enemySpawnInterval = Math.max(400, 1200 - level*60);
}

/* Boss spawn */
function spawnBoss(level){
  const boss = new Enemy(WIDTH/2, -120, 'boss', Math.min(12 + level*2, 60), 10, 300, 80, '#ffbb88');
  boss.isBoss = true;
  boss.phase = 0;
  boss.update = function(dt){
    this.t += dt*1000;
    // entry move to y=120
    if (this.y < 120){
      this.y += 50*dt;
      this.x += Math.cos(this.t/800)*25*dt;
    } else {
      // phases: alternate shoot patterns
      if (Math.floor(this.t/2500) % 2 === 0){
        // fan shots
        if (this.t - this.lastShot > 350){
          this.lastShot = this.t;
          const n = 8 + Math.floor(level/3);
          for (let i=0;i<n;i++){
            const angle = (i/(n-1) - 0.5) * Math.PI*0.8;
            const vx = Math.sin(angle)*200;
            const vy = Math.cos(angle)*200;
            GAME.bullets.push(new Bullet(this.x, this.y+20, vx, vy, 'enemy',1,'#ffcc88',6));
          }
          AudioEngine.playTone(220,0.12,'sawtooth',0.08);
        }
      } else {
        // targeted shots
        if (this.t - this.lastShot > 420){
          this.lastShot = this.t;
          const p = GAME.player;
          if (p){
            for (let i=0;i<3;i++){
              const dx = (p.x + rand(-40,40)) - this.x;
              const dy = (p.y + rand(-30,30)) - this.y;
              const mag = Math.hypot(dx,dy) || 1;
              const speed = 220 + i*30;
              GAME.bullets.push(new Bullet(this.x, this.y+20, dx/mag*speed, dy/mag*speed, 'enemy',1,'#ffcc88',6));
            }
            AudioEngine.playTone(480,0.06,'square',0.06);
          }
        }
      }
    }
    // bounding
    if (this.x < 60) this.x = 60;
    if (this.x > WIDTH-60) this.x = WIDTH-60;
  };
  GAME.enemies.push(boss);
}

/* --------------------------
   Collision helpers
   -------------------------- */
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function circleHit(a,b){
  return Math.hypot(a.x-b.x, a.y-b.y) <= (a.radius||a.size/2) + (b.radius||b.size/2);
}

/* --------------------------
   Game Loop
   -------------------------- */
function update(dt){
  if (GAME.state !== 'playing' || GAME.paused) return;
  // update player
  if (GAME.player) GAME.player.update(dt);

  // spawn logic
  if (now() - GAME.lastEnemySpawn > GAME.enemySpawnInterval){
    // spawn single enemy occasionally to keep action
    const x = rand(40, WIDTH-40);
    const y = -20;
    const pattern = Math.random() < 0.45 ? 'sine' : 'straight';
    const hp = clamp(1 + Math.floor(GAME.level/3), 1, 10);
    GAME.enemies.push(new Enemy(x,y,pattern,hp, 80 + GAME.level*6, 10 + GAME.level*2, 18, '#ff8f8f'));
    GAME.lastEnemySpawn = now();
  }

  // wave boss conditions
  if (GAME.enemies.length === 0 && now() - GAME.lastWaveTime > 900 && GAME.wave % 4 === 0){
    // spawn boss every 4 waves
    spawnBoss(GAME.level);
    GAME.level++;
  } else if (GAME.enemies.length === 0 && now() - GAME.lastWaveTime > 1200){
    spawnEnemyWave(GAME.level);
    GAME.level++;
  }

  // update bullets
  for (let b of GAME.bullets) b.update(dt);
  GAME.bullets = GAME.bullets.filter(b=>!b.dead);

  // update enemies
  for (let e of GAME.enemies) e.update(dt);
  GAME.enemies = GAME.enemies.filter(e=>!e.dead);

  // update powerups
  for (let p of GAME.powups) p.update(dt);
  GAME.powups = GAME.powups.filter(p=>!p.dead);

  // update particles
  for (let pa of GAME.particles) pa.update(dt);
  GAME.particles = GAME.particles.filter(p=>p.life>0);

  // collisions: player bullets -> enemies
  for (let b of GAME.bullets){
    if (b.owner !== 'player') continue;
    for (let e of GAME.enemies){
      if (circleHit(b, e)){
        e.takeDamage(b.damage);
        b.dead = true;
        break;
      }
    }
  }
  // enemy bullets -> player
  for (let b of GAME.bullets){
    if (b.owner !== 'enemy') continue;
    if (!GAME.player) continue;
    const p = GAME.player;
    const r = {x:p.x,y:p.y,size:30};
    if (circleHit(b, r)){
      b.dead = true;
      p.takeHit(1);
    }
  }
  // enemies collide with player
  for (let e of GAME.enemies){
    if (!GAME.player) continue;
    if (Math.hypot(e.x - GAME.player.x, e.y - GAME.player.y) < (e.size/1.8 + 16)){
      e.die();
      GAME.player.takeHit(1);
    }
  }
  // powerups -> player
  for (let pu of GAME.powups){
    if (!GAME.player) continue;
    const p = GAME.player;
    if (Math.hypot(pu.x - p.x, pu.y - p.y) < 24){
      pu.apply(p);
      pu.dead = true;
    }
  }

  // update HUD
  hud.style.display = 'block';
  hud.innerText = `SCORE: ${GAME.score} · LIVES: ${GAME.lives} · LEVEL: ${GAME.level}`;
}

/* Draw everything */
function draw(){
  // background gradient
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  // stars
  drawStars();

  // particles
  for (let p of GAME.particles) p.draw(ctx);

  // powerups
  for (let pu of GAME.powups) pu.draw(ctx);

  // bullets
  for (let b of GAME.bullets) b.draw(ctx);

  // enemies
  for (let e of GAME.enemies) e.draw(ctx);

  // player
  if (GAME.player) GAME.player.draw(ctx);

  // HUD overlay in canvas (score small)
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.font = '14px Inter, monospace';
  ctx.fillStyle = '#bfe9ff';
  ctx.fillText('SCORE ' + GAME.score, 16, 22);
  ctx.restore();
}

/* Simple starfield */
let starSeed = [];
function initStars(){
  starSeed = [];
  for (let i=0;i<120;i++){
    starSeed.push({x:rand(0,WIDTH), y:rand(0,HEIGHT), s:rand(0.3,1.8)});
  }
}
function drawStars(){
  if (starSeed.length === 0) initStars();
  // subtle parallax depending on time
  ctx.save();
  for (let s of starSeed){
    const y = (s.y + (now()/50)*(s.s*0.2)) % HEIGHT;
    ctx.fillStyle = `rgba(255,255,255,${0.12 * s.s})`;
    ctx.beginPath(); ctx.arc(s.x, y, s.s, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

/* Main loop */
function mainLoop(t){
  const dt = Math.min(0.032, (t - lastTime)/1000); // clamp dt
  lastTime = t;
  if (GAME.running && !GAME.paused){
    update(dt);
  }
  draw();
  requestAnimationFrame(mainLoop);
}

/* --------------------------
   Game control functions
   -------------------------- */

function startNewGame(){
  // reset state
  GAME.running = true;
  GAME.paused = false;
  GAME.score = 0;
  GAME.level = 1;
  GAME.wave = 0;
  GAME.lives = 3;
  GAME.enemies = [];
  GAME.bullets = [];
  GAME.powups = [];
  GAME.particles = [];
  GAME.player = new Player();
  GAME.lastEnemySpawn = now();
  GAME.lastWaveTime = now();
  // initial wave
  spawnEnemyWave(1);
  // UI
  document.getElementById('overlay').style.display = 'none';
  GAME.state = 'playing';
  hud.style.display = 'block';
  // sound
  if (audioEnabled) AudioEngine.playTone(880,0.08,'sine',0.06);
}

function pauseGame(){
  if (!GAME.running) return;
  GAME.paused = true;
  GAME.state = 'paused';
  // show pause menu
  showPanel('pauseMenu');
}

function resumeGame(){
  if (!GAME.running) return;
  GAME.paused = false;
  GAME.state = 'playing';
  hidePanels();
}

/* Toggle pause: called by P */
function togglePause(){
  if (!GAME.running) return;
  if (GAME.paused) resumeGame();
  else pauseGame();
}

/* Game over */
function GAMEOver(){
  GAME.running = false;
  GAME.paused = false;
  GAME.state = 'gameover';
  // persist highscore
  if (GAME.score > GAME.highscore){
    GAME.highscore = GAME.score;
    localStorage.setItem('gd_highscore', String(GAME.highscore));
  }
  // show game over panel
  document.getElementById('finalScore').innerText = GAME.score;
  showPanel('gameOverPanel');
}

/* --------------------------
   UI and menu helpers
   -------------------------- */
function showPanel(id){
  // hide all panels then show specific
  const ids = ['mainMenu','pauseMenu','howPanel','gameOverPanel'];
  for (let i of ids) document.getElementById(i).style.display = 'none';
  document.getElementById('overlay').style.display = 'flex';
  document.getElementById(id).style.display = 'block';
  // hide HUD when menu visible
  hud.style.display = id === 'mainMenu' ? 'none' : 'block';
  // update highscore
  document.getElementById('highscore').innerText = GAME.highscore;
}
function hidePanels(){
  document.getElementById('overlay').style.display = 'none';
  hud.style.display = 'block';
}

/* Attach buttons */
document.getElementById('btnStart').addEventListener('click', ()=>{
  startNewGame();
});
document.getElementById('btnContinue').addEventListener('click', ()=>{
  if (GAME.state === 'paused') resumeGame();
});
document.getElementById('btnHow').addEventListener('click', ()=>{
  showPanel('howPanel');
});
document.getElementById('btnHowBack').addEventListener('click', ()=>{
  showPanel('mainMenu');
});
document.getElementById('btnResume').addEventListener('click', ()=> resumeGame());
document.getElementById('btnRestart').addEventListener('click', ()=>{
  startNewGame();
});
document.getElementById('btnMain').addEventListener('click', ()=>{
  // show main menu
  GAME.running = false;
  GAME.state = 'menu';
  showPanel('mainMenu');
});
document.getElementById('btnRetry').addEventListener('click', ()=> startNewGame());
document.getElementById('btnMenuFromOver').addEventListener('click', ()=>{
  showPanel('mainMenu');
});

// toggle sound
const btnSound = document.getElementById('btnToggleSound');
btnSound.addEventListener('click', ()=>{
  audioEnabled = !audioEnabled;
  btnSound.innerText = 'Som: ' + (audioEnabled ? 'ON' : 'OFF');
  if (audioEnabled) AudioEngine.ensure();
});

/* Keyboard to start via Enter or Space when on menu */
window.addEventListener('keydown', e=>{
  if (GAME.state === 'menu' && (e.code==='Enter' || e.code==='Space')) startNewGame();
});

/* --------------------------
   Initialize
   -------------------------- */
function init(){
  // set up default menu
  showPanel('mainMenu');
  // init stars
  initStars();
  // initial resize
  resizeCanvasToWindow();
  // start loop
  lastTime = performance.now();
  requestAnimationFrame(mainLoop);
}
init();

/* --------------------------
   Small polish: autosave and debug helpers
   -------------------------- */
setInterval(()=>{
  // occasionally clean arrays to avoid leaks (simple housekeeping)
  GAME.particles = GAME.particles.filter(p=>p.life>0);
  GAME.powups = GAME.powups.filter(p=>!p.dead);
}, 5000);

/* End of file — divertido e pronto para jogar! */
</script>
</body>
</html>
